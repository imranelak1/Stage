<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chef Centre - T3Shield</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo-icon img {
            width: 100%;
            height: 100%;
            /* Removed filter that was making logo invisible */
        }
        
        .header-text h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .header-text p {
            font-size: 16px;
            opacity: 0.9;
        }
        
        .header-actions {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .user-info {
            font-size: 16px;
            font-weight: 500;
        }
        
        .logout-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s ease;
        }
        
        .logout-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px 20px;
        }
        
        .status-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .status-item {
            background: white;
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }
        
        .status-item:hover {
            transform: translateY(-2px);
        }
        
        .status-number {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .status-label {
            font-size: 15px;
            color: #7f8c8d;
            font-weight: 500;
        }
        
        /* Color coding for status indicators - More distinctive colors */
        .status-yellow .status-number { color: #f1c40f; }
        .status-orange .status-number { color: #fd7e14; }
        .status-red .status-number { color: #dc3545; }
        .status-gray .status-number { color: #6c757d; }
        
        /* Verification status styles */
        .status-confirmed {
            color: #28a745;
            font-weight: bold;
            background: #d4edda;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #c3e6cb;
        }
        
        .status-denied {
            color: #6c757d;
            font-weight: bold;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }
        
        .chart-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: space-between;
        }
        
        .chart-title-text {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .zoom-icon {
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            color: #6c757d;
            transition: all 0.3s ease;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }
        
        .zoom-icon:hover {
            background: #e9ecef;
            color: #495057;
            transform: scale(1.1);
        }
        
        .chart-container {
            position: relative;
            height: 350px;
        }
        
        .tables-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }
        
        .table-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }
        
        .table-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
            text-align: center;
        }
        
        .table-container {
            overflow-x: auto;
            max-height: 400px;
            border-radius: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
            border: 1px solid #ddd;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .datetime-cell {
            font-size: 14px; /* Larger font for desktop */
            line-height: 1.4;
        }
        
        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
            position: sticky;
            top: -1px;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .action-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .verify-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin: 0;
            font-weight: 500;
            transition: all 0.3s ease;
            width: 100px;
        }
        
        .confirm-btn {
            background: #28a745;
            color: white;
        }
        
        .confirm-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }
        
        .deny-btn {
            background: #dc3545;
            color: white;
        }
        
        .deny-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
        }
        
        .status-confirmed {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .status-denied {
            color: #95a5a6;
            font-weight: bold;
        }

        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            font-size: 12px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Enhanced Responsive Design */
        @media (max-width: 1400px) {
            .container {
                max-width: 1200px;
            }
        }
        
        @media (max-width: 1200px) {
            .charts-grid {
                grid-template-columns: repeat(auto-fit, min-width(300px, 1fr));
            }
            
            .chart-container {
                height: 320px;
            }
            
            .container {
                padding: 25px 20px;
            }
        }
        
        @media (max-width: 992px) {
            .header-content {
                flex-direction: column;
                text-align: center;
                gap: 20px;
            }
            
            .logo {
                justify-content: center;
            }
            
            .header-actions {
                justify-content: center;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .chart-container {
                height: 300px;
            }
        }
        
        @media (max-width: 768px) {
            .header-text h1 {
                font-size: 22px;
            }
            
            .header-text p {
                font-size: 15px;
            }
            
            .container {
                padding: 20px 15px;
            }
            
            .status-indicators {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 15px;
            }
            
            .status-item {
                padding: 20px 15px;
            }
            
            .status-number {
                font-size: 30px;
            }
            
            .status-label {
                font-size: 13px;
            }
            
            .chart-card {
                padding: 20px;
            }
            
            .chart-container {
                height: 280px;
            }
            
            .table-card {
                padding: 20px;
            }
            
            .table-title {
                font-size: 18px;
            }
            
            th, td {
                padding: 10px 8px;
                font-size: 14px;
            }
        }
        
        @media (max-width: 576px) {
            .header-text h1 {
                font-size: 20px;
            }
            
            .header-text p {
                font-size: 14px;
            }
            
            .user-info {
                font-size: 14px;
            }
            
            .logout-btn {
                padding: 8px 16px;
                font-size: 13px;
            }
            
            .container {
                padding: 15px 10px;
            }
            
            .status-indicators {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            
            .status-item {
                padding: 15px 10px;
            }
            
            .status-number {
                font-size: 26px;
            }
            
            .status-label {
                font-size: 12px;
            }
            
            .chart-card {
                padding: 15px;
            }
            
            .chart-title {
                font-size: 16px;
            }
            
            .chart-container {
                height: 250px;
            }
            
            .table-card {
                padding: 15px;
            }
            
            .table-title {
                font-size: 16px;
            }
            
            th, td {
                padding: 8px 6px;
                font-size: 13px;
            }
            
            .verify-btn {
                padding: 4px 8px;
                font-size: 11px;
            }
        }
        
        @media (max-width: 480px) {
            .status-indicators {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                height: 220px;
            }
            
            table {
                min-width: 480px;
            }
            
            th, td {
                padding: 6px 4px;
                font-size: 12px;
            }
            
            .filters select {
                min-width: 0; /* Override desktop min-width for mobile */
            }
            
            .datetime-cell {
                font-size: 12px; /* Smaller font for mobile */
            }
            
            .verify-btn {
                padding: 3px 6px;
                font-size: 11px;
            }
        }
        
        /* Loading Animation */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            color: #7f8c8d;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .filter-panel {
            margin-bottom: 20px;
        }
        .filter-toggle {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 22px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.2s;
        }
        .filter-toggle:active, .filter-toggle:focus {
            background: #4b5fc0;
        }
        .chevron {
            display: inline-block;
            transition: transform 0.3s;
            font-size: 22px;
        }
        .chevron.open {
            transform: rotate(180deg);
        }
        .filters {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px 20px;
            margin-top: 5px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: center;
        }
        .datetime-filters, .dropdown-filters {
            display: flex;
            gap: 30px;
            align-items: center;
        }
        .filters label {
            font-weight: 500;
            margin-right: 8px;
        }
        .filters select, .filters input[type="time"], .filters input[type="date"], .filters input[type="datetime-local"] {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
            margin-right: 10px;
            font-size: 14px;
        }
        .filters select {
            min-width: 150px;
        }
        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        @media (max-width: 700px) {
            .filters {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            .filter-group {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            .filter-toggle {
                width: 100%;
                justify-content: space-between;
                font-size: 16px;
                padding: 12px 10px;
            }
        }
        
        /* Mobile optimizations for better space usage */
        @media (max-width: 480px) {
            .container {
                padding: 10px 5px;
            }
            
            .filter-panel {
                margin-bottom: 15px;
                width: 60%;
                float: left;
            }
            
            .filters {
                padding: 8px;
                gap: 8px;
                font-size: 12px;
            }
            
            .filters label {
                font-size: 11px;
                margin-right: 4px;
            }
            
            .filters select, .filters input[type="datetime-local"] {
                padding: 4px 6px;
                font-size: 11px;
                margin-right: 6px;
                height: 28px;
            }
            
            .filters select {
                min-width: 0; /* Override desktop min-width for mobile */
            }
            
            .filter-group {
                gap: 3px;
            }
            
            .filter-toggle {
                font-size: 12px;
                padding: 0 8px;
                margin-bottom: 5px;
                height: 28px;
            }
            
            .chevron {
                font-size: 16px;
            }
            
            .status-indicators {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
                margin-bottom: 15px;
                width: 38%;
                float: right;
                clear: right;
                transition: height 0.3s ease;
                display: grid;
                grid-template-rows: repeat(2, 1fr);
            }
            
            .status-item {
                padding: 8px 6px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
            
            .status-number {
                font-size: 18px;
                margin-bottom: 2px;
            }
            
            .status-label {
                font-size: 9px;
            }
            
            .chart-card {
                padding: 10px;
                margin-bottom: 15px;
                clear: both;
            }
            
            .chart-container {
                height: 200px;
            }
            
            .table-card {
                padding: 10px;
                margin-bottom: 15px;
                clear: both;
            }
            
            .table-title {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            /* When filters are collapsed, status indicators take full width */
            .filter-panel.collapsed {
                width: 100%;
            }
            
            .filter-panel.collapsed + .status-indicators {
                width: 100%;
                float: none;
            }
            
            /* Mobile filter layout: datetime inputs on left, dropdowns on right */
            .filters .datetime-filters {
                display: flex;
                flex-direction: column;
                gap: 6px;
                width: 100%;
            }
            
            .filters .dropdown-filters {
                display: flex;
                gap: 8px;
                width: 100%;
            }
            
            .filters .dropdown-filters .filter-group {
                flex: 1;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .verify-btn {
                padding: 3px 6px;
                font-size: 11px;
                width: 80px;
            }
        }

        /* --- Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }
        #modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        #modal-message {
            font-size: 16px;
            margin-bottom: 20px;
            line-height: 1.5;
            color: #555;
        }
        .modal-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }
        .modal-btn.confirm {
            background: #dc3545;
            color: white;
        }
        .modal-btn.deny {
            background: #6c757d;
            color: white;
        }
        .modal-btn.cancel {
            background: #eee;
            color: #333;
        }
        .modal-btn.confirm:hover { background: #c82333; }
        .modal-btn.deny:hover { background: #5a6268; }
        .modal-btn.cancel:hover { background: #ddd; }

        .modal-details-grid {
            text-align: left;
            margin-bottom: 20px;
            background: #f8f9fa;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            font-size: 15px;
        }
        .modal-details-grid strong {
            font-weight: 600;
            color: #333;
        }

        /* WhatsApp-style Radio Button Filter */
        .filter-radio-group {
            display: flex;
            background: #f8f9fa;
            border-radius: 25px;
            padding: 4px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            margin: 10px auto;
        }
        
        .filter-radio-group input[type="radio"] {
            display: none;
        }
        
        .filter-radio-group label {
            flex: 1;
            padding: 10px 16px;
            text-align: center;
            cursor: pointer;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .filter-radio-group input[type="radio"]:checked + label {
            background: #007bff;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
        }
        
        .filter-radio-group label:hover {
            background: rgba(0, 123, 255, 0.1);
            color: #007bff;
        }
        
        .filter-radio-group input[type="radio"]:checked + label:hover {
            background: #0056b3;
        }

        /* Chart Modal Styles */
        .chart-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .chart-modal-content {
            position: relative;
            background-color: white;
            margin: 2% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 1200px;
            height: 90%;
            max-height: 800px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .chart-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f8f9fa;
        }
        
        .chart-modal-title {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .chart-modal-close {
            cursor: pointer;
            padding: 10px;
            border-radius: 8px;
            background: #f8f9fa;
            color: #6c757d;
            transition: all 0.3s ease;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }
        
        .chart-modal-close:hover {
            background: #e9ecef;
            color: #495057;
            transform: scale(1.1);
        }
        
        .chart-modal-container {
            height: calc(100% - 80px);
            position: relative;
        }
        
        .chart-modal-canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Responsive adjustments for modal */
        @media (max-width: 768px) {
            .chart-modal-content {
                width: 95%;
                margin: 5% auto;
                padding: 20px;
                height: 85%;
            }
            
            .chart-modal-title {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">
                    <img src="/static/logo-cropped.svg" alt="T3Shield Logo" style="width: 100%; height: 100%; object-fit: contain;">
                </div>
                <div class="header-text">
                    <h1>Dashboard Chef de Centre</h1>
                </div>
            </div>
            <div class="header-actions">
                <span class="user-info" id="username">Chef de centre</span>
                <button class="logout-btn" onclick="logout()">D√©connexion</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Collapsible Filter Panel -->
        <div class="filter-panel">
            <button class="filter-toggle" onclick="toggleFilters()">
                Filtres
                <span class="chevron" id="chevron">&#9660;</span>
            </button>
            <div class="filters" id="filters" style="display:none;">
                <div class="datetime-filters">
                    <div class="filter-group">
                        <label>De :</label>
                        <input type="datetime-local" id="startDateTime">
                    </div>
                    <div class="filter-group">
                        <label>√Ä :</label>
                        <input type="datetime-local" id="endDateTime">
                    </div>
                </div>
                <div class="dropdown-filters">
                    <div class="filter-group">
                        <label for="salleFilter">Salle :</label>
                        <select id="salleFilter"><option value="">Toutes</option></select>
                    </div>
                    <div class="filter-group">
                        <label for="matiereFilter">Session :</label>
                        <select id="matiereFilter"><option value="">Toutes</option></select>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Indicators -->
        <div class="status-indicators">
            <div class="status-item status-yellow">
                <div class="status-number" id="total-general">0</div>
                <div class="status-label">Risque Potentiel</div>
            </div>
            <div class="status-item status-orange">
                <div class="status-number" id="total-mobility">0</div>
                <div class="status-label">Risque Annot√©</div>
            </div>
            <div class="status-item status-red">
                <div class="status-number" id="total-confirmed">0</div>
                <div class="status-label">Risque Confirm√©</div>
            </div>
            <div class="status-item status-gray">
                <div class="status-number" id="total-denied">0</div>
                <div class="status-label">Fausse Alerte</div>
            </div>
        </div>

        <!-- Priority Table - Mobility Analyses -->
        <div class="table-card">
            <div class="table-title">V√©rification - Risque Annot√©</div>
            
            <!-- WhatsApp-style Radio Button Filter -->
            <div class="filter-radio-group">
                <input type="radio" id="filter-all" name="verification-filter" value="all">
                <label for="filter-all">Tous</label>
                
                <input type="radio" id="filter-unverified" name="verification-filter" value="unverified" checked>
                <label for="filter-unverified">Non v√©rifi√©s</label>
                
                <input type="radio" id="filter-verified" name="verification-filter" value="verified">
                <label for="filter-verified">V√©rifi√©s</label>
            </div>
            
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>CNE</th>
                            <th>Salle</th>
                            <th>Session</th>
                            <th>Action</th>
                            <th>Nbr D√©tection</th>
                        </tr>
                    </thead>
                    <tbody id="mobility-tbody">
                        <tr><td colspan="6" class="loading"><div class="spinner"></div>Chargement...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
         <!-- Secondary Table - General Analyses -->
         <div class="table-card">
            <div class="table-title">Risque Potentiel</div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Op√©rateur</th>
                            <th>Type</th>
                            <th>Salle</th>
                            <th>Session</th>
                            <th>Nbr D√©tection</th>
                        </tr>
                    </thead>
                    <tbody id="general-tbody">
                        <tr><td colspan="6" class="loading"><div class="spinner"></div>Chargement...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Cheat Rate Charts -->
        <div class="charts-grid">
            <div class="chart-card">
                <div class="chart-title">
                    <div class="chart-title-text">
                        Taux de Triche par Salle
                    </div>
                    <div class="zoom-icon" onclick="openChartModal('cheatSalleChart', 'üéØ Taux de Triche par Salle')">
                        üîç
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="cheatSalleChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">
                    <div class="chart-title-text">
                        Taux de Triche par Session
                    </div>
                    <div class="zoom-icon" onclick="openChartModal('cheatSessionChart', 'üìä Taux de Triche par Session')">
                        üîç
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="cheatSessionChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">
                    <div class="chart-title-text">
                        Distribution Horaire du Taux de Triche
                    </div>
                    <div class="zoom-icon" onclick="openChartModal('cheatTimeChart', '‚è∞ Distribution Horaire du Taux de Triche')">
                        üîç
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="cheatTimeChart"></canvas>
                </div>
            </div>
        </div>
         <!-- Charts -->
        <div class="charts-grid">
            <div class="chart-card">
                <div class="chart-title">
                    <div class="chart-title-text">
                        Analyses par Session
                    </div>
                    <div class="zoom-icon" onclick="openChartModal('matiereChart', 'üìä Analyses par Session')">
                        üîç
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="matiereChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">
                    <div class="chart-title-text">
                        Analyses par Salle
                    </div>
                    <div class="zoom-icon" onclick="openChartModal('salleChart', 'üè´ Analyses par Salle')">
                        üîç
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="salleChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">
                    <div class="chart-title-text">
                        √âvolution Temporelle
                    </div>
                    <div class="zoom-icon" onclick="openChartModal('timeChart', 'üìà √âvolution Temporelle')">
                        üîç
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="timeChart"></canvas>
                </div>
            </div>
        </div>

       
    </div>

    <div id="confirmation-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="modal-title">Confirmation Requise</h3>
            <div id="modal-details" class="modal-details-grid" style="display:none;"></div>
            <p id="modal-message"></p>
            <div class="modal-actions">
                <button id="modal-cancel-btn" class="modal-btn cancel">Annuler</button>
                <button id="modal-confirm-btn" class="modal-btn confirm">Confirmer</button>
            </div>
        </div>
    </div>

    <!-- Chart Modal -->
    <div id="chart-modal" class="chart-modal">
        <div class="chart-modal-content">
            <div class="chart-modal-header">
                <div class="chart-modal-title" id="chart-modal-title">
                    üìä Chart Title
                </div>
                <div class="chart-modal-close" onclick="closeChartModal()">
                    ‚úï
                </div>
            </div>
            <div class="chart-modal-container">
                <canvas id="chart-modal-canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        let matiereChart, salleChart, timeChart, cheatSalleChart, cheatSessionChart, cheatTimeChart;
        let codeCentre;
        let socket;

        document.addEventListener('DOMContentLoaded', function() {
            // Get center code from URL
            const pathParts = window.location.pathname.split('/');
            codeCentre = pathParts[pathParts.indexOf('centre') + 1];
            
            console.log('[DEBUG] Dashboard loading - checking session validity');
            
            // Check if we have any session data and if it's stale
            const storedCenter = sessionStorage.getItem('chefCenter');
            if (!storedCenter) {
                console.log('[DEBUG] No stored center data found');
            }
            
            // Validate session first
            validateSession().then(isValid => {
                if (!isValid) {
                    console.log('[DEBUG] Session invalid, redirecting to login');
                    // Clear all client-side data
                    sessionStorage.clear();
                    localStorage.clear();
                    // Redirect to login if session is invalid
                    window.location.href = `/chef/centre/${codeCentre}`;
                    return;
                }
                
                // Load center info
                fetchCenterInfo();
                
                initializeCharts();
                loadAnalyses();
                initializeWebSocket();
                
                // Refresh every 30 seconds as backup
                setInterval(loadAnalyses, 5000);
            });

            // Set default datetime to today 8:00 AM to 6:00 PM
            const today = new Date();
            const startDateTime = new Date(today);
            startDateTime.setHours(8, 0, 0, 0);
            const endDateTime = new Date(today);
            endDateTime.setHours(18, 0, 0, 0);
            
            const formatDateTime = (date) => {
                const yyyy = date.getFullYear();
                const mm = String(date.getMonth() + 1).padStart(2, '0');
                const dd = String(date.getDate()).padStart(2, '0');
                const hh = String(date.getHours()).padStart(2, '0');
                const min = String(date.getMinutes()).padStart(2, '0');
                return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
            };
            
            document.getElementById('startDateTime').value = formatDateTime(startDateTime);
            document.getElementById('endDateTime').value = formatDateTime(endDateTime);
            currentFilters.startDateTime = formatDateTime(startDateTime);
            currentFilters.endDateTime = formatDateTime(endDateTime);

            // Initialize mobile layout state
            if (window.innerWidth <= 480) {
                const filterPanel = document.querySelector('.filter-panel');
                filterPanel.classList.add('collapsed');
                document.querySelector('.status-indicators').style.height = 'auto';
            }

            // ... existing code ...
            // Add filter listeners
            document.getElementById('startDateTime').addEventListener('change', function(e) {
                currentFilters.startDateTime = e.target.value;
                applyFiltersAndUpdate();
            });
            document.getElementById('endDateTime').addEventListener('change', function(e) {
                currentFilters.endDateTime = e.target.value;
                applyFiltersAndUpdate();
            });
            document.getElementById('salleFilter').addEventListener('change', function(e) {
                currentFilters.salle = e.target.value;
                applyFiltersAndUpdate();
            });
            document.getElementById('matiereFilter').addEventListener('change', function(e) {
                currentFilters.matiere = e.target.value;
                applyFiltersAndUpdate();
            });
            
            // Add radio button filter listeners
            document.querySelectorAll('input[name="verification-filter"]').forEach(radio => {
                radio.addEventListener('change', function(e) {
                    currentFilters.verificationStatus = e.target.value;
                    applyFiltersAndUpdate();
                });
            });
        });
        
        async function validateSession() {
            try {
                const response = await fetch(`/chef/centre/${codeCentre}/api/analyses`);
                return response.ok;
            } catch (error) {
                console.error('Session validation error:', error);
                return false;
            }
        }
        
        async function fetchCenterInfo() {
            try {
                const response = await fetch(`/chef/centre/${codeCentre}/api/info`);
                if (response.ok) {
                    const centerInfo = await response.json();
                    document.getElementById('username').textContent = centerInfo.name_fr || centerInfo.lycee || 'Chef de centre';
                } else {
                    // Fallback to default values
                    document.getElementById('username').textContent = 'Chef de centre';
                }
            } catch (error) {
                console.error('Error fetching center info:', error);
                // Fallback to default values
                document.getElementById('username').textContent = 'Chef de centre';
            }
        }

        function initializeCharts() {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                    }
                },
                scales: {
                    y: { 
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                }
            };

            // Mati√®re Chart (Stacked Bar)
            const matiereCtx = document.getElementById('matiereChart').getContext('2d');
            matiereChart = new Chart(matiereCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Risque Potentiel',
                            data: [],
                            backgroundColor: '#f1c40f',
                            borderColor: '#f39c12',
                            borderWidth: 1
                        },
                        {
                            label: 'Risque Annot√©',
                            data: [],
                            backgroundColor: '#fd7e14',
                            borderColor: '#e67e22',
                            borderWidth: 1
                        },
                        {
                            label: 'Risque Confirm√©',
                            data: [],
                            backgroundColor: '#dc3545',
                            borderColor: '#c82333',
                            borderWidth: 1
                        },
                        {
                            label: 'Fausse Alerte',
                            data: [],
                            backgroundColor: '#6c757d',
                            borderColor: '#5a6268',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        x: { stacked: true },
                        y: { stacked: true, beginAtZero: true }
                    }
                }
            });

            // Salle Chart (Stacked Bar)
            const salleCtx = document.getElementById('salleChart').getContext('2d');
            salleChart = new Chart(salleCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Risque Potentiel',
                            data: [],
                            backgroundColor: '#f1c40f',
                            borderColor: '#f39c12',
                            borderWidth: 1
                        },
                        {
                            label: 'Risque Annot√©',
                            data: [],
                            backgroundColor: '#fd7e14',
                            borderColor: '#e67e22',
                            borderWidth: 1
                        },
                        {
                            label: 'Risque Confirm√©',
                            data: [],
                            backgroundColor: '#dc3545',
                            borderColor: '#c82333',
                            borderWidth: 1
                        },
                        {
                            label: 'Fausse Alerte',
                            data: [],
                            backgroundColor: '#6c757d',
                            borderColor: '#5a6268',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        x: { stacked: true },
                        y: { stacked: true, beginAtZero: true }
                    }
                }
            });

            // Time Chart (Line Chart)
            const timeCtx = document.getElementById('timeChart').getContext('2d');
            timeChart = new Chart(timeCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Risque Potentiel',
                            data: [],
                            backgroundColor: 'rgba(241, 196, 15, 0.1)',
                            borderColor: '#f1c40f',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointBackgroundColor: '#f1c40f',
                            pointBorderColor: '#f39c12',
                            pointBorderWidth: 2,
                            pointRadius: 5,
                            pointHoverRadius: 7
                        },
                        {
                            label: 'Risque Annot√©',
                            data: [],
                            backgroundColor: 'rgba(253, 126, 20, 0.1)',
                            borderColor: '#fd7e14',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointBackgroundColor: '#fd7e14',
                            pointBorderColor: '#e67e22',
                            pointBorderWidth: 2,
                            pointRadius: 5,
                            pointHoverRadius: 7
                        },
                        {
                            label: 'Risque Confirm√©',
                            data: [],
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            borderColor: '#dc3545',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointBackgroundColor: '#dc3545',
                            pointBorderColor: '#c82333',
                            pointBorderWidth: 2,
                            pointRadius: 5,
                            pointHoverRadius: 7
                        },
                        {
                            label: 'Fausse Alerte',
                            data: [],
                            backgroundColor: 'rgba(108, 117, 125, 0.1)',
                            borderColor: '#6c757d',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointBackgroundColor: '#6c757d',
                            pointBorderColor: '#5a6268',
                            pointBorderWidth: 2,
                            pointRadius: 5,
                            pointHoverRadius: 7
                        }
                    ]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        x: { 
                            stacked: false,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        y: { 
                            stacked: false, 
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    plugins: {
                        ...chartOptions.plugins,
                        legend: {
                            ...chartOptions.plugins.legend,
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        }
                    },
                    elements: {
                        line: {
                            borderWidth: 3
                        },
                        point: {
                            radius: 5,
                            hoverRadius: 7
                        }
                    }
                }
            });

            // Cheat Rate Charts
            // Cheat Rate by Salle Chart
            const cheatSalleCtx = document.getElementById('cheatSalleChart').getContext('2d');
            cheatSalleChart = new Chart(cheatSalleCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Taux de Triche (%)',
                            data: [],
                            backgroundColor: '#e74c3c',
                            borderColor: '#c0392b',
                            borderWidth: 2,
                            borderRadius: 4
                        }
                    ]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    },
                    plugins: {
                        ...chartOptions.plugins,
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Cheat Rate by Session Chart
            const cheatSessionCtx = document.getElementById('cheatSessionChart').getContext('2d');
            cheatSessionChart = new Chart(cheatSessionCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Taux de Triche (%)',
                            data: [],
                            backgroundColor: '#3498db',
                            borderColor: '#2980b9',
                            borderWidth: 2,
                            borderRadius: 4
                        }
                    ]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    },
                    plugins: {
                        ...chartOptions.plugins,
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Cheat Rate Time Distribution Chart
            const cheatTimeCtx = document.getElementById('cheatTimeChart').getContext('2d');
            cheatTimeChart = new Chart(cheatTimeCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Taux de Triche (%)',
                            data: [],
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderColor: '#3498db',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#3498db',
                            pointBorderColor: '#2980b9',
                            pointBorderWidth: 2,
                            pointRadius: 5,
                            pointHoverRadius: 7
                        }
                    ]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        x: {
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        y: {
                            max: 100,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    },
                    plugins: {
                        ...chartOptions.plugins,
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '%';
                                }
                            }
                        }
                    },
                    elements: {
                        line: {
                            borderWidth: 3
                        },
                        point: {
                            radius: 5,
                            hoverRadius: 7
                        }
                    }
                }
            });
        }

        function initializeWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                socket = new WebSocket(wsUrl);

                socket.onopen = function(event) {
                    console.log('WebSocket connected');
                };

                socket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('WebSocket message received:', data);
                        
                        // Handle real-time updates
                        if (data.event === 'new_analysis' || data.event === 'verification_update') {
                            // Apply batch logic before updating UI
                            handleRealtimeUpdate(data);
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };

                socket.onclose = function(event) {
                    console.log('WebSocket disconnected. Attempting to reconnect...');
                    // Attempt to reconnect after 5 seconds
                    setTimeout(initializeWebSocket, 5000);
                };

                socket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                };
            } catch (error) {
                console.error('Error initializing WebSocket:', error);
                // Retry after 5 seconds
                setTimeout(initializeWebSocket, 5000);
            }
        }

        function handleRealtimeUpdate(data) {
            console.log('Handling real-time update with batch logic');
            
            // For verification updates, just reload to get clean state
            if (data.event === 'verification_update') {
                loadAnalyses();
                return;
            }
            
            // For new analysis, apply batch logic before reloading
            if (data.event === 'new_analysis' && data.analysis) {
                const analysis = data.analysis;
                
                // Apply batch logic similar to main map
                if (analysis.type === 'analyse_mobilite') {
                    // For mobility analyses, check if ANY analyses (verified or unverified) exist for this CNE+location+day
                    const analysisDate = new Date(analysis.timestamp).toDateString();
                    const locationKey = `${analysis.aref || ''}_${analysis.dp || ''}_${analysis.ville || ''}_${analysis.lycee || ''}_${analysis.salle || ''}_${analysis.matiere || ''}_${analysis.cne || ''}_${analysisDate}`;
                    
                    // Check if we have any existing analyses for this location key
                    const existingAnalyses = Object.values(analysesDatabase).filter(existing => {
                        if (existing.type !== 'analyse_mobilite') return false;
                        
                        const existingDate = new Date(existing.timestamp).toDateString();
                        const existingLocationKey = `${existing.aref || ''}_${existing.dp || ''}_${existing.ville || ''}_${existing.lycee || ''}_${existing.salle || ''}_${existing.matiere || ''}_${existing.cne || ''}_${existingDate}`;
                        return existingLocationKey === locationKey;
                    });
                    
                    // If we have existing analyses for this CNE+location+day, this is a new batch
                    if (existingAnalyses.length > 0) {
                        console.log(`New batch detected for CNE ${analysis.cne}, existing analyses:`, existingAnalyses.map(a => ({ batch: a.batch, verified: a.verification_action || 'unverified' })));
                        // Reload to apply proper batch logic
                        loadAnalyses();
                        return;
                    }
                } else {
                    // For general analyses, check if this location+day combination exists
                    const locationKey = `${analysis.aref || ''}_${analysis.dp || ''}_${analysis.ville || ''}_${analysis.lycee || ''}_${analysis.salle || ''}_${analysis.matiere || ''}`;
                    const analysisDate = new Date(analysis.date || analysis.timestamp).toDateString();
                    const fullKey = `${locationKey}_${analysisDate}`;
                    
                    const existingAnalyses = Object.values(analysesDatabase).filter(existing => {
                        if (existing.type === 'analyse_mobilite') return false;
                        const existingLocationKey = `${existing.aref || ''}_${existing.dp || ''}_${existing.ville || ''}_${existing.lycee || ''}_${existing.salle || ''}_${existing.matiere || ''}`;
                        const existingDate = new Date(existing.date || existing.timestamp).toDateString();
                        const existingFullKey = `${existingLocationKey}_${existingDate}`;
                        return existingFullKey === fullKey;
                    });
                    
                    if (existingAnalyses.length > 0) {
                        console.log(`New batch detected for location, existing batches:`, existingAnalyses.map(a => a.batch));
                        // Don't increment counts, just reload to show latest batch
                        loadAnalyses();
                        return;
                    }
                }
            }
            
            // If no batch logic applies, do normal reload
            loadAnalyses();
        }

        async function loadAnalyses() {
            try {
                const response = await fetch(`/chef/centre/${codeCentre}/api/analyses`);
                
                if (response.status === 401 || response.status === 403) {
                    // Session expired or unauthorized, redirect to login
                    console.log('[DEBUG] Unauthorized access detected, clearing session and redirecting');
                    sessionStorage.clear();
                    localStorage.clear();
                    window.location.replace(`/chef/centre/${codeCentre}`);
                    return;
                }
                
                const data = await response.json();
                
                if (response.ok) {
                    updateStatusIndicators(data);
                    updateCharts(data);
                    updateTables(data);
                } else {
                    console.error('Error response:', data);
                }
            } catch (error) {
                console.error('Error loading analyses:', error);
                // If network error, check if we can still access the API
                try {
                    const testResponse = await fetch(`/chef/centre/${codeCentre}/api/analyses`);
                    if (testResponse.status === 401 || testResponse.status === 403) {
                        console.log('[DEBUG] Session expired during network test, clearing and redirecting');
                        sessionStorage.clear();
                        localStorage.clear();
                        window.location.replace(`/chef/centre/${codeCentre}`);
                    }
                } catch (testError) {
                    console.error('Network connectivity issue:', testError);
                }
            }
        }

        function updateStatusIndicators(data) {
            document.getElementById('total-general').textContent = data.general_analyses.length;
            
            // Count only unverified mobility analyses (Risque Annot√©)
            const unverifiedMobility = data.mobility_analyses.filter(a => 
                !a.verification_action || (a.verification_action !== 'confirm' && a.verification_action !== 'deny')
            ).length;
            
            const confirmed = data.mobility_analyses.filter(a => a.verification_action === 'confirm').length;
            const denied = data.mobility_analyses.filter(a => a.verification_action === 'deny').length;
            
            document.getElementById('total-mobility').textContent = unverifiedMobility;
            document.getElementById('total-confirmed').textContent = confirmed;
            document.getElementById('total-denied').textContent = denied;
        }

        function updateCharts(data) {
            // Prepare data for charts
            const matiereData = {};
            const salleData = {};
            const timeData = {};

            // Process general analyses (Risque Potentiel)
            data.general_analyses.forEach(analysis => {
                const matiere = analysis.matiere || 'Non sp√©cifi√©';
                const salle = analysis.salle || 'Non sp√©cifi√©';
                const date = new Date(analysis.date);
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const hour = date.getHours().toString().padStart(2, '0');
                const timeKey = `${day}/${month} ${hour}:00`;

                // Mati√®re data
                if (!matiereData[matiere]) {
                    matiereData[matiere] = { potentiel: 0, annote: 0, confirme: 0, fausse: 0 };
                }
                matiereData[matiere].potentiel++;

                // Salle data
                if (!salleData[salle]) {
                    salleData[salle] = { potentiel: 0, annote: 0, confirme: 0, fausse: 0 };
                }
                salleData[salle].potentiel++;

                // Time data
                if (!timeData[timeKey]) {
                    timeData[timeKey] = { potentiel: 0, annote: 0, confirme: 0, fausse: 0, timestamp: date.getTime() };
                }
                timeData[timeKey].potentiel++;
            });

            // Process mobility analyses
            data.mobility_analyses.forEach(analysis => {
                const matiere = analysis.matiere || 'Non sp√©cifi√©';
                const salle = analysis.salle || 'Non sp√©cifi√©';
                const date = new Date(analysis.timestamp);
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const hour = date.getHours().toString().padStart(2, '0');
                const timeKey = `${day}/${month} ${hour}:00`;

                // Determine category
                let category = 'annote'; // Default: Risque Annot√©
                if (analysis.verification_action === 'confirm') {
                    category = 'confirme'; // Risque Confirm√©
                } else if (analysis.verification_action === 'deny') {
                    category = 'fausse'; // Fausse Alerte
                }

                // Mati√®re data
                if (!matiereData[matiere]) {
                    matiereData[matiere] = { potentiel: 0, annote: 0, confirme: 0, fausse: 0 };
                }
                matiereData[matiere][category]++;

                // Salle data
                if (!salleData[salle]) {
                    salleData[salle] = { potentiel: 0, annote: 0, confirme: 0, fausse: 0 };
                }
                salleData[salle][category]++;

                // Time data
                if (!timeData[timeKey]) {
                    timeData[timeKey] = { potentiel: 0, annote: 0, confirme: 0, fausse: 0, timestamp: date.getTime() };
                }
                timeData[timeKey][category]++;
            });

            // Update Mati√®re Chart
            const matiereLabels = Object.keys(matiereData).slice(0, 10); // Top 10
            matiereChart.data.labels = matiereLabels;
            matiereChart.data.datasets[0].data = matiereLabels.map(label => matiereData[label].potentiel);
            matiereChart.data.datasets[1].data = matiereLabels.map(label => matiereData[label].annote);
            matiereChart.data.datasets[2].data = matiereLabels.map(label => matiereData[label].confirme);
            matiereChart.data.datasets[3].data = matiereLabels.map(label => matiereData[label].fausse);
            matiereChart.update();

            // Update Salle Chart
            const salleLabels = Object.keys(salleData).slice(0, 10); // Top 10
            salleChart.data.labels = salleLabels;
            salleChart.data.datasets[0].data = salleLabels.map(label => salleData[label].potentiel);
            salleChart.data.datasets[1].data = salleLabels.map(label => salleData[label].annote);
            salleChart.data.datasets[2].data = salleLabels.map(label => salleData[label].confirme);
            salleChart.data.datasets[3].data = salleLabels.map(label => salleData[label].fausse);
            salleChart.update();

            // Update Time Chart - Cumulative Evolution
            const timeLabels = Object.keys(timeData).sort((a, b) => {
                // Sort by timestamp for proper chronological order
                return timeData[a].timestamp - timeData[b].timestamp;
            });
            
            // Calculate cumulative data for evolution temporelle
            let cumulativePotentiel = 0;
            let cumulativeAnnote = 0;
            let cumulativeConfirme = 0;
            let cumulativeFausse = 0;
            
            const cumulativePotentielData = [];
            const cumulativeAnnoteData = [];
            const cumulativeConfirmeData = [];
            const cumulativeFausseData = [];
            
            timeLabels.forEach(label => {
                cumulativePotentiel += timeData[label].potentiel;
                cumulativeAnnote += timeData[label].annote;
                cumulativeConfirme += timeData[label].confirme;
                cumulativeFausse += timeData[label].fausse;
                
                cumulativePotentielData.push(cumulativePotentiel);
                cumulativeAnnoteData.push(cumulativeAnnote);
                cumulativeConfirmeData.push(cumulativeConfirme);
                cumulativeFausseData.push(cumulativeFausse);
            });
            
            timeChart.data.labels = timeLabels;
            timeChart.data.datasets[0].data = cumulativePotentielData;
            timeChart.data.datasets[1].data = cumulativeAnnoteData;
            timeChart.data.datasets[2].data = cumulativeConfirmeData;
            timeChart.data.datasets[3].data = cumulativeFausseData;
            timeChart.update();

            // Update Cheat Rate Charts
            updateCheatRateCharts(data);
        }

        function updateCheatRateCharts(data) {
            // Prepare cheat rate data
            const cheatSalleData = {};
            const cheatSessionData = {};
            const cheatTimeData = {};

            // Process mobility analyses for cheat rates (only confirmed cases count as cheating)
            data.mobility_analyses.forEach(analysis => {
                const salle = analysis.salle || 'Non sp√©cifi√©';
                const matiere = analysis.matiere || 'Non sp√©cifi√©';
                const date = new Date(analysis.timestamp);
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const hour = date.getHours().toString().padStart(2, '0');
                const timeKey = `${day}/${month} ${hour}:00`;

                // Initialize data structures
                if (!cheatSalleData[salle]) {
                    cheatSalleData[salle] = { total: 0, confirmed: 0 };
                }
                if (!cheatSessionData[matiere]) {
                    cheatSessionData[matiere] = { total: 0, confirmed: 0 };
                }
                if (!cheatTimeData[timeKey]) {
                    cheatTimeData[timeKey] = { total: 0, confirmed: 0, timestamp: date.getTime() };
                }

                // Count total analyses
                cheatSalleData[salle].total++;
                cheatSessionData[matiere].total++;
                cheatTimeData[timeKey].total++;

                // Count confirmed cases (actual cheating)
                if (analysis.verification_action === 'confirm') {
                    cheatSalleData[salle].confirmed++;
                    cheatSessionData[matiere].confirmed++;
                    cheatTimeData[timeKey].confirmed++;
                }
            });

            // Calculate cheat rates and update charts
            // Cheat Rate by Salle
            const salleLabels = Object.keys(cheatSalleData).slice(0, 10); // Top 10
            const salleRates = salleLabels.map(salle => {
                const data = cheatSalleData[salle];
                return data.total > 0 ? (data.confirmed / data.total) * 100 : 0;
            });

            cheatSalleChart.data.labels = salleLabels;
            cheatSalleChart.data.datasets[0].data = salleRates;
            cheatSalleChart.update();

            // Cheat Rate by Session
            const sessionLabels = Object.keys(cheatSessionData).slice(0, 10); // Top 10
            const sessionRates = sessionLabels.map(session => {
                const data = cheatSessionData[session];
                return data.total > 0 ? (data.confirmed / data.total) * 100 : 0;
            });

            cheatSessionChart.data.labels = sessionLabels;
            cheatSessionChart.data.datasets[0].data = sessionRates;
            cheatSessionChart.update();

            // Cheat Rate Time Distribution
            const timeLabels = Object.keys(cheatTimeData).sort((a, b) => {
                return cheatTimeData[a].timestamp - cheatTimeData[b].timestamp;
            });
            
            // Calculate cumulative cheat rates up to each time point
            let cumulativeTotal = 0;
            let cumulativeConfirmed = 0;
            const cumulativeRates = [];
            
            timeLabels.forEach(timeKey => {
                const data = cheatTimeData[timeKey];
                cumulativeTotal += data.total;
                cumulativeConfirmed += data.confirmed;
                
                const cumulativeRate = cumulativeTotal > 0 ? (cumulativeConfirmed / cumulativeTotal) * 100 : 0;
                cumulativeRates.push(cumulativeRate);
            });

            cheatTimeChart.data.labels = timeLabels;
            cheatTimeChart.data.datasets[0].data = cumulativeRates;
            cheatTimeChart.update();
        }

        // Batch logic functions (copied from data.js)
        let analysesDatabase = {}; // For duplicate checking

        function formatDateTimeForCell(dateString) {
            const d = new Date(dateString);
            if (isNaN(d)) {
                return 'N/A';
            }
            const dateStr = d.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
            const timeStr = d.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            return `<span class="datetime-cell">${dateStr}<br>${timeStr}</span>`;
        }
        
        function processAnalyses(data) {
            // Clear old data
            analysesDatabase = {};
            
            // Apply correct batch logic for mobility analyses
            const processedMobility = [];
            
            if (data.mobility_analyses && data.mobility_analyses.length > 0) {
                // Group mobility analyses by location+CNE+day
                const locationGroups = {};
                
                data.mobility_analyses.forEach(analysis => {
                    // Create location key with date
                    const analysisDate = new Date(analysis.timestamp).toDateString();
                    const locationKey = `${analysis.aref}-${analysis.dp}-${analysis.ville}-${analysis.lycee}-${analysis.salle}-${analysis.matiere}-${analysis.cne}-${analysisDate}`;
                    
                    if (!locationGroups[locationKey]) {
                        locationGroups[locationKey] = {
                            verified: [],
                            unverified: []
                        };
                    }
                    
                    if (analysis.verification_action === 'confirm' || analysis.verification_action === 'deny') {
                        // Add to verified list - keep all verified batches
                        locationGroups[locationKey].verified.push(analysis);
                    } else {
                        // Add to unverified list - will filter to highest batch only
                        locationGroups[locationKey].unverified.push(analysis);
                    }
                });
                
                // For each location group, keep all verified + highest unverified batch only if it's newer
                Object.values(locationGroups).forEach(group => {
                    // Add all verified analyses (permanent)
                    group.verified.forEach(analysis => {
                        analysis.id = analysis.id_analyse || `mobility_verified_${Date.now()}_${Math.random()}`;
                        analysesDatabase[analysis.id] = analysis;
                        processedMobility.push(analysis);
                    });
                    
                    // Find the highest verified batch number
                    let highestVerifiedBatch = 0;
                    if (group.verified.length > 0) {
                        group.verified.forEach(verifiedAnalysis => {
                            const verifiedBatch = verifiedAnalysis.batch || 1;
                            if (verifiedBatch > highestVerifiedBatch) {
                                highestVerifiedBatch = verifiedBatch;
                            }
                        });
                    }
                    
                    // For unverified analyses, keep only the highest batch IF it's higher than highest verified
                    if (group.unverified.length > 0) {
                        let highestUnverifiedBatch = 0;
                        let highestUnverifiedAnalysis = null;
                        
                        group.unverified.forEach(analysis => {
                            const batch = analysis.batch || 1;
                            if (batch > highestUnverifiedBatch) {
                                highestUnverifiedBatch = batch;
                                highestUnverifiedAnalysis = analysis;
                            }
                        });
                        
                        // Only add unverified if it's newer than the newest verified batch
                        if (highestUnverifiedAnalysis && highestUnverifiedBatch > highestVerifiedBatch) {
                            highestUnverifiedAnalysis.id = highestUnverifiedAnalysis.id_analyse || `mobility_${Date.now()}_${Math.random()}`;
                            highestUnverifiedAnalysis.id_analyse = highestUnverifiedAnalysis.id_analyse; // Ensure id_analyse is available for verification
                            analysesDatabase[highestUnverifiedAnalysis.id] = highestUnverifiedAnalysis;
                            processedMobility.push(highestUnverifiedAnalysis);
                        }
                    }
                });
            }
            
            // Process general analyses with batch logic (same as before)
            const generalLocationBatches = {};
            
            data.general_analyses.forEach(analysis => {
                const locationKey = `${analysis.aref}-${analysis.dp}-${analysis.ville}-${analysis.lycee}-${analysis.salle}-${analysis.matiere}`;
                const batch = analysis.batch || 1;
                
                if (!generalLocationBatches[locationKey] || batch > generalLocationBatches[locationKey].batch) {
                    generalLocationBatches[locationKey] = {
                        batch: batch,
                        analysis: analysis
                    };
                }
            });
            
            const processedGeneral = [];
            Object.values(generalLocationBatches).forEach(locationData => {
                const analysis = locationData.analysis;
                analysis.batch = analysis.batch || 1;
                analysis.id = analysis.id || `general_${Date.now()}_${Math.random()}`;
                
                analysesDatabase[analysis.id] = analysis;
                processedGeneral.push(analysis);
            });
            
            return {
                mobility_analyses: processedMobility,
                general_analyses: processedGeneral
            };
        }

        function updateTables(data) {
            // Apply batch logic before displaying
            const processedData = processAnalyses(data);
            
            // Apply verification status filter only to mobility analyses for table display
            const verificationStatus = currentFilters.verificationStatus;
            let filteredMobilityAnalyses = processedData.mobility_analyses;
            
            if (verificationStatus !== 'all') {
                filteredMobilityAnalyses = processedData.mobility_analyses.filter(analysis => {
                    if (verificationStatus === 'unverified') {
                        return !analysis.verification_action;
                    } else if (verificationStatus === 'verified') {
                        return analysis.verification_action;
                    }
                    return true;
                });
            }
            
            // Mobility analyses
            const mobilityTbody = document.getElementById('mobility-tbody');
            mobilityTbody.innerHTML = '';
            
            if (filteredMobilityAnalyses.length === 0) {
                mobilityTbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #7f8c8d;">Aucune analyse de mobilit√©</td></tr>';
            } else {
                filteredMobilityAnalyses.forEach(analysis => {
                    const row = document.createElement('tr');
                    let actionCell = '';
                    
                    if (analysis.verification_action === 'confirm') {
                        actionCell = '<span class="status-confirmed">Confirm√©</span>';
                    } else if (analysis.verification_action === 'deny') {
                        actionCell = '<span class="status-denied">Fausse Alerte</span>';
                    } else {
                        actionCell = `
                            <div class="action-buttons-container">
                                <button class="verify-btn confirm-btn" onclick="verifyAnalysis(${analysis.id_analyse}, 'confirm')" data-analysis-id="${analysis.id_analyse}">
                                    <span class="loading-spinner" style="display: none;">‚ü≥</span>
                                    <span class="btn-text">Confirmer</span>
                                </button>
                                <button class="verify-btn deny-btn" onclick="verifyAnalysis(${analysis.id_analyse}, 'deny')" data-analysis-id="${analysis.id_analyse}">
                                    <span class="loading-spinner" style="display: none;">‚ü≥</span>
                                    <span class="btn-text">Refuser</span>
                                </button>
                            </div>
                        `;
                    }
                    
                    const batch = analysis.batch || 1;
                    
                    row.innerHTML = `
                        <td>${formatDateTimeForCell(analysis.timestamp)}</td>
                        <td>${analysis.cne || 'N/A'}</td>
                        <td>${analysis.salle || 'N/A'}</td>
                        <td>${analysis.matiere || 'N/A'}</td>
                        <td>${actionCell}</td>
                        <td>${batch}</td>
                    `;
                    
                    mobilityTbody.appendChild(row);
                });
            }

            // General analyses (no verification status filter applied)
            const generalTbody = document.getElementById('general-tbody');
            generalTbody.innerHTML = '';
            
            if (data.general_analyses.length === 0) {
                generalTbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #7f8c8d;">Aucune analyse g√©n√©rale</td></tr>';
            } else {
                data.general_analyses.slice(0, 50).forEach(analysis => { // Limit to 50 most recent
                    const row = document.createElement('tr');
                    const batch = analysis.batch || 1;
                    
                    row.innerHTML = `
                        <td>${formatDateTimeForCell(analysis.date)}</td>
                        <td>${analysis.operateur || 'N/A'}</td>
                        <td>${analysis.type_communication || 'N/A'}</td>
                        <td>${analysis.salle || 'N/A'}</td>
                        <td>${analysis.matiere || 'N/A'}</td>
                        <td>${batch}</td>
                    `;
                    
                    generalTbody.appendChild(row);
                });
            }
        }

        function showConfirmationModal(analysis, action) {
            const modal = document.getElementById('confirmation-modal');
            const modalMessage = document.getElementById('modal-message');
            const modalDetails = document.getElementById('modal-details');
            const confirmBtn = document.getElementById('modal-confirm-btn');
            const cancelBtn = document.getElementById('modal-cancel-btn');

            // Populate the details if they exist
            if (analysis.cne) {
                const d = new Date(analysis.timestamp);
                const dateStr = d.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                const timeStr = d.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
        
                modalDetails.innerHTML = `
                    <strong>Date:</strong>     <span>${dateStr} ${timeStr}</span>
                    <strong>CNE:</strong>      <span>${analysis.cne}</span>
                    <strong>Salle:</strong>    <span>${analysis.salle}</span>
                    <strong>Session:</strong>  <span>${analysis.matiere}</span>
                `;
                modalDetails.style.display = 'grid';
            } else {
                modalDetails.innerHTML = '';
                modalDetails.style.display = 'none';
            }

            if (action === 'confirm') {
                modalMessage.innerHTML = "√ätes-vous certain de vouloir marquer ce risque comme <strong>Confirm√©</strong> ? Cette action est irr√©versible.";
                confirmBtn.textContent = 'Confirmer';
                confirmBtn.className = 'modal-btn confirm';
            } else {
                modalMessage.innerHTML = "√ätes-vous certain de vouloir marquer ce risque comme <strong>Fausse Alerte</strong> ? Cette action est irr√©versible.";
                confirmBtn.textContent = 'Refuser';
                confirmBtn.className = 'modal-btn deny';
            }

            modal.classList.add('visible');

            const handleConfirm = () => {
                performVerification(analysis.id_analyse, action);
                modal.classList.remove('visible');
                confirmBtn.removeEventListener('click', handleConfirm);
                cancelBtn.removeEventListener('click', handleCancel);
            };

            const handleCancel = () => {
                modal.classList.remove('visible');
                confirmBtn.removeEventListener('click', handleConfirm);
                cancelBtn.removeEventListener('click', handleCancel);
            };

            confirmBtn.addEventListener('click', handleConfirm);
            cancelBtn.addEventListener('click', handleCancel);
        }

        async function verifyAnalysis(idAnalyse, action) {
            // Find the analysis object from our local database
            const analysis = Object.values(analysesDatabase).find(a => a.id_analyse === idAnalyse);
        
            // If we found it, show the modal with full details
            if (analysis) {
                showConfirmationModal(analysis, action);
            } else {
                // Fallback in case the data isn't found (should not happen)
                console.error(`Analysis data for ID ${idAnalyse} not found.`);
                // Show a modal with only the ID
                showConfirmationModal({ id_analyse: idAnalyse }, action);
            }
        }

        async function performVerification(idAnalyse, action) {
            // Find the button group in the table
            const buttonGroup = document.querySelector(`button[data-analysis-id="${idAnalyse}"]`).parentElement;
            const allButtons = buttonGroup.querySelectorAll('.verify-btn');
            
            // Set loading state on the correct button
            const clickedButton = action === 'confirm' ? buttonGroup.querySelector('.confirm-btn') : buttonGroup.querySelector('.deny-btn');
            setButtonLoading(clickedButton, true);
            allButtons.forEach(btn => btn.disabled = true);
            
            try {
                const response = await fetch(`/chef/centre/${codeCentre}/api/verify`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        id_analyse_mobilite: idAnalyse,
                        action: action
                    })
                });

                const result = await response.json();
                
                if (response.ok) {
                    console.log('Verification successful:', result);
                    
                    // Update the button group to show the verification status
                    const statusText = action === 'confirm' ? 'Confirm√©' : 'Fausse Alerte';
                    const statusClass = action === 'confirm' ? 'status-confirmed' : 'status-denied';
                    buttonGroup.innerHTML = `<span class="${statusClass}">${statusText}</span>`;
                    
                    // Update the counts immediately
                    const currentConfirmed = parseInt(document.getElementById('total-confirmed').textContent);
                    const currentDenied = parseInt(document.getElementById('total-denied').textContent);
                    const currentMobility = parseInt(document.getElementById('total-mobility').textContent);
                    
                    if (action === 'confirm') {
                        document.getElementById('total-confirmed').textContent = currentConfirmed + 1;
                    } else {
                        document.getElementById('total-denied').textContent = currentDenied + 1;
                    }
                    
                    // Decrease mobility count
                    document.getElementById('total-mobility').textContent = Math.max(0, currentMobility - 1);
                    
                    // Update the analysis in our local database to reflect the verification
                    for (const id in analysesDatabase) {
                        const analysis = analysesDatabase[id];
                        if (analysis.id_analyse === idAnalyse) {
                            analysis.verification_action = action;
                            break;
                        }
                    }
                    
                    console.log('Verification completed - status updated locally');
                    
                } else {
                    console.error('Verification error:', result.detail);
                    // Reset buttons on error
                    setButtonLoading(clickedButton, false);
                    allButtons.forEach(btn => btn.disabled = false);
                    alert('Erreur: ' + result.detail);
                }
            } catch (error) {
                console.error('Error verifying analysis:', error);
                // Reset buttons on error
                setButtonLoading(clickedButton, false);
                allButtons.forEach(btn => btn.disabled = false);
                alert('Erreur de connexion');
            }
        }

        function setButtonLoading(button, isLoading) {
            const spinner = button.querySelector('.loading-spinner');
            const text = button.querySelector('.btn-text');
            
            if (isLoading) {
                if (spinner) {
                    spinner.style.display = 'inline-block';
                    spinner.style.animation = 'spin 1s linear infinite';
                }
                if (text) text.style.opacity = '0.7';
                button.style.cursor = 'not-allowed';
            } else {
                if (spinner) {
                    spinner.style.display = 'none';
                    spinner.style.animation = 'none';
                }
                if (text) text.style.opacity = '1';
                button.style.cursor = 'pointer';
            }
        }

        async function logout() {
            try {
                // Call logout API to clear server session
                await fetch(`/chef/centre/${codeCentre}/logout`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'  // Ensure cookies are sent
                });
            } catch (error) {
                console.error('Error during logout:', error);
            }
            
            // Clear all client-side data
            sessionStorage.clear();  // Clear all session storage
            localStorage.clear();    // Clear all local storage
            
            // Clear any cached data
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => {
                        caches.delete(name);
                    });
                });
            }
            
            // Force page refresh to ensure clean state
            window.location.replace(`/chef/centre/${codeCentre}`);
        }

        function toggleFilters() {
            const filters = document.getElementById('filters');
            const chevron = document.getElementById('chevron');
            const filterPanel = document.querySelector('.filter-panel');
            const isOpen = filters.style.display !== 'none';

            filters.style.display = isOpen ? 'none' : 'flex';
            chevron.classList.toggle('open', !isOpen);
            filterPanel.classList.toggle('collapsed', isOpen);
            
            // Adjust layout for mobile
            if (window.innerWidth <= 480) {
                const statusIndicators = document.querySelector('.status-indicators');
                if (!isOpen) { // If we just opened it
                    // Defer height calculation to allow for rendering
                    requestAnimationFrame(() => {
                        const filterHeight = filterPanel.offsetHeight;
                        statusIndicators.style.height = `${filterHeight}px`;
                    });
                } else { // If we just closed it
                    statusIndicators.style.height = 'auto'; // Reset height
                }
            }
        }

        // --- Filter logic ---
        let currentFilters = {
            startDateTime: '',
            endDateTime: '',
            salle: '',
            matiere: '',
            verificationStatus: 'unverified'  // Default to unverified
        };

        // Helper to populate salle/matiere dropdowns
        function populateFilterDropdowns(data) {
            const salles = new Set();
            const matieres = new Set();
            data.general_analyses.forEach(a => {
                if (a.salle) salles.add(a.salle);
                if (a.matiere) matieres.add(a.matiere);
            });
            data.mobility_analyses.forEach(a => {
                if (a.salle) salles.add(a.salle);
                if (a.matiere) matieres.add(a.matiere);
            });
            const salleFilter = document.getElementById('salleFilter');
            const matiereFilter = document.getElementById('matiereFilter');
            salleFilter.innerHTML = '<option value="">Toutes</option>' + Array.from(salles).map(s => `<option value="${s}">${s}</option>`).join('');
            matiereFilter.innerHTML = '<option value="">Toutes</option>' + Array.from(matieres).map(m => `<option value="${m}">${m}</option>`).join('');

            // Restore the previously selected value to prevent the glitch
            salleFilter.value = currentFilters.salle;
            matiereFilter.value = currentFilters.matiere;
        }

        // Filter and update dashboard
        let lastRawData = null;
        function applyFiltersAndUpdate() {
            if (!lastRawData) return;
            const filtered = filterData(lastRawData);
            updateStatusIndicators(filtered);
            updateCharts(filtered);
            updateTables(filtered);
        }

        function filterData(data) {
            // Filter by datetime range, salle, matiere (verification status only applies to table display)
            const startDateTime = currentFilters.startDateTime;
            const endDateTime = currentFilters.endDateTime;
            const salle = currentFilters.salle;
            const matiere = currentFilters.matiere;
            
            // Helper to check if datetime is in range
            function inDateTimeRange(dateStr) {
                if (!startDateTime || !endDateTime) return true;
                const d = new Date(dateStr);
                const start = new Date(startDateTime);
                const end = new Date(endDateTime);
                return d >= start && d <= end;
            }
            
            return {
                general_analyses: data.general_analyses.filter(a =>
                    inDateTimeRange(a.date) &&
                    (!salle || a.salle === salle) &&
                    (!matiere || a.matiere === matiere)
                ),
                mobility_analyses: data.mobility_analyses.filter(a =>
                    inDateTimeRange(a.timestamp) &&
                    (!salle || a.salle === salle) &&
                    (!matiere || a.matiere === matiere)
                )
            };
        }

        // Patch loadAnalyses to store lastRawData and update filters
        async function loadAnalyses() {
            try {
                const response = await fetch(`/chef/centre/${codeCentre}/api/analyses`);
                if (response.status === 401 || response.status === 403) {
                    sessionStorage.clear();
                    localStorage.clear();
                    window.location.replace(`/chef/centre/${codeCentre}`);
                    return;
                }
                const data = await response.json();
                if (response.ok) {
                    lastRawData = data;
                    populateFilterDropdowns(data);
                    applyFiltersAndUpdate();
                } else {
                    console.error('Error response:', data);
                }
            } catch (error) {
                // ... existing error handling ...
            }
        }

        // Chart Modal Functions
        let modalChart = null;

        function openChartModal(chartId, title) {
            const modal = document.getElementById('chart-modal');
            const modalTitle = document.getElementById('chart-modal-title');
            const modalCanvas = document.getElementById('chart-modal-canvas');
            
            // Set modal title
            modalTitle.innerHTML = title;
            
            // Get the original chart
            const originalChart = getChartInstance(chartId);
            if (!originalChart) {
                console.error('Chart not found:', chartId);
                return;
            }
            
            // Show modal
            modal.style.display = 'block';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
            
            // Create new chart in modal with same data and options
            const ctx = modalCanvas.getContext('2d');
            
            // Destroy previous modal chart if exists
            if (modalChart) {
                modalChart.destroy();
            }
            
            // Create new chart with enhanced options for modal
            modalChart = new Chart(ctx, {
                type: originalChart.config.type,
                data: originalChart.config.data,
                options: {
                    ...originalChart.config.options,
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        ...originalChart.config.options.plugins,
                        legend: {
                            ...originalChart.config.options.plugins.legend,
                            position: 'top',
                            labels: {
                                ...originalChart.config.options.plugins.legend.labels,
                                font: {
                                    size: 14
                                }
                            }
                        }
                    },
                    scales: {
                        ...originalChart.config.options.scales,
                        x: {
                            ...originalChart.config.options.scales.x,
                            ticks: {
                                ...originalChart.config.options.scales.x.ticks,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        y: {
                            ...originalChart.config.options.scales.y,
                            ticks: {
                                ...originalChart.config.options.scales.y.ticks,
                                font: {
                                    size: 12
                                }
                            }
                        }
                    }
                }
            });
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeChartModal();
                }
            });
            
            // Add escape key to close
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeChartModal();
                }
            });
        }

        function closeChartModal() {
            const modal = document.getElementById('chart-modal');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scrolling
            
            // Destroy modal chart
            if (modalChart) {
                modalChart.destroy();
                modalChart = null;
            }
            
            // Remove event listeners
            modal.removeEventListener('click', closeChartModal);
            document.removeEventListener('keydown', closeChartModal);
        }

        function getChartInstance(chartId) {
            switch (chartId) {
                case 'matiereChart':
                    return matiereChart;
                case 'salleChart':
                    return salleChart;
                case 'timeChart':
                    return timeChart;
                case 'cheatSalleChart':
                    return cheatSalleChart;
                case 'cheatSessionChart':
                    return cheatSessionChart;
                case 'cheatTimeChart':
                    return cheatTimeChart;
                default:
                    return null;
            }
        }
    </script>
</body>
</html>